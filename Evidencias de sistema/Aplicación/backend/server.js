// backend/server.js
require('dotenv').config();
const express = require('express');
const http = require('http');
const cors = require('cors');
const { Server } = require('socket.io');
const path = require('path');
const db = require('./models');
// ... otras importaciones de rutas
const planificacionMantenimientoRoutes = require('./routes/planificacionMantenimiento.routes');
const ordenTrabajoRoutes = require('./routes/ordenTrabajo.routes.js'); // <--- 1. IMPORTAR NUEVAS RUTAS
// Rutas refactorizadas
const planificacionRoutesRefactored = require('./routes/planificacion.routes.refactored');
const ordenTrabajoRoutesRefactored = require('./routes/ordenTrabajo.routes.refactored');
// Rutas API
const vehiculoRoutes = require('./routes/vehiculos.js');
const statsRoutes = require('./routes/stats.routes.js');
const siniestroRoutes = require('./routes/siniestros');
const combustibleRoutes = require('./routes/combustibles');
const vehicleRoutes = require('./routes/vehiculos');
const authRoutes = require('./routes/auth');
const routeRoutes = require('./routes/rutas');
const asignacionRecorridoRoutes = require('./routes/asignacionesRecorrido');
const usuarioRoutes = require('./routes/usuario.routes.js');
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
});

app.use(cors({ origin: '*' }));
app.use(express.json());

app.use((req, res, next) => {
  req.io = io;
  next();
});

async function testDbConnectionAndSync() {
  try {
    await db.sequelize.authenticate();
    console.log(
      '‚úÖ Conexi√≥n a la Base de Datos (Sequelize) establecida correctamente.'
    );
  } catch (error) {
    console.error(
      '‚ùå Error al conectar o sincronizar con la Base de Datos:',
      error
    );
  }
}
testDbConnectionAndSync();

app.get('/', (req, res) => {
  res.send('¬°API de Gesti√≥n de Flota v1.0 funcionando!');
});

// --- REGISTRO DE RUTAS API ---

app.use('/api/stats', statsRoutes);
app.use('/api/siniestros', siniestroRoutes);
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
app.use('/api/combustibles', combustibleRoutes);
app.use('/api/vehicles', vehicleRoutes);
app.use('/api/vehiculos', vehiculoRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/rutas', routeRoutes);
app.use('/api/asignaciones-recorrido', asignacionRecorridoRoutes);
app.use('/api/planificaciones', planificacionMantenimientoRoutes);
app.use('/api/ordenes-trabajo', ordenTrabajoRoutes); // <--- 2. REGISTRAR NUEVAS RUTAS
// Rutas refactorizadas con generaci√≥n autom√°tica de OTs
app.use('/api/planificaciones-v2', planificacionRoutesRefactored);
app.use('/api/ordenes-trabajo-v2', ordenTrabajoRoutesRefactored);
app.use('/api/usuarios', usuarioRoutes);
// L√≥gica de Socket.IO
io.on('connection', socket => {
  console.log(`üîå Cliente conectado a Socket.IO: ${socket.id}`);

  socket.on('disconnect', reason => {
    console.log(
      `üîå Cliente desconectado de Socket.IO: ${socket.id}. Raz√≥n: ${reason}`
    );
    if (socket.simulationIntervalId) {
      clearInterval(socket.simulationIntervalId);
      console.log(
        `[Simulaci√≥n] Intervalo de simulaci√≥n detenido para socket ${socket.id} debido a desconexi√≥n.`
      );
      delete socket.simulationIntervalId;
    }
  });

  // (Opcional) Suscripci√≥n a un room espec√≠fico de asignaci√≥n
  socket.on('subscribeToAsignacion', data => {
    const asignacionId = data?.asignacionId;
    if (asignacionId) {
      const roomName = `asignacion_${asignacionId}`;
      socket.join(roomName);
      console.log(`[Socket] Cliente ${socket.id} se uni√≥ al room ${roomName}`);
    } else {
      console.warn(
        `[Socket] Intento de suscripci√≥n sin asignacionId por cliente ${socket.id}`
      );
    }
  });

  // (Opcional) Desuscripci√≥n de un room espec√≠fico de asignaci√≥n
  socket.on('unsubscribeFromAsignacion', data => {
    const asignacionId = data?.asignacionId;
    if (asignacionId) {
      const roomName = `asignacion_${asignacionId}`;
      socket.leave(roomName);
      console.log(`[Socket] Cliente ${socket.id} abandon√≥ el room ${roomName}`);
    }
  });

  socket.on('startSimulation', async data => {
    const routeId = data?.routeId;
    const vehicleNumericId = data?.vehicleId;
    const asignacionIdSimulacion = data?.asignacionId;

    console.log(
      `[Socket] Recibida petici√≥n 'startSimulation': Ruta ID=${routeId}, Veh√≠culo ID=${vehicleNumericId}, Asignaci√≥n ID=${asignacionIdSimulacion}`
    );

    if (!routeId || vehicleNumericId === undefined) {
      console.error(
        '[Simulaci√≥n] Error: No se proporcion√≥ routeId o vehicleId.'
      );
      socket.emit('simulationError', {
        message:
          'Falta ID de la ruta o ID del veh√≠culo para iniciar la simulaci√≥n.',
      });
      return;
    }

    if (socket.simulationIntervalId) {
      clearInterval(socket.simulationIntervalId);
      console.log(
        `[Simulaci√≥n] Limpiando intervalo de simulaci√≥n anterior para socket ${socket.id}`
      );
      delete socket.simulationIntervalId;
    }

    let puntosSimulacionArray = null;
    let nombreDeLaRuta = `Ruta ${routeId}`;

    try {
      const rutaEncontrada = await db.Ruta.findByPk(routeId);

      if (!rutaEncontrada || !rutaEncontrada.puntosRuta) {
        console.error(
          `[Simulaci√≥n] Ruta ID ${routeId} no encontrada o no tiene 'puntosRuta'.`
        );
        socket.emit('simulationError', {
          message: `Ruta ${routeId} no encontrada o datos de puntos ausentes.`,
        });
        return;
      }
      nombreDeLaRuta = rutaEncontrada.nombreRuta || nombreDeLaRuta;

      try {
        puntosSimulacionArray =
          typeof rutaEncontrada.puntosRuta === 'string'
            ? JSON.parse(rutaEncontrada.puntosRuta)
            : rutaEncontrada.puntosRuta;

        if (
          !Array.isArray(puntosSimulacionArray) ||
          puntosSimulacionArray.length === 0 ||
          !puntosSimulacionArray.every(
            p =>
              Array.isArray(p) &&
              p.length === 2 &&
              typeof p[0] === 'number' &&
              typeof p[1] === 'number'
          )
        ) {
          throw new Error(
            'Los puntos de la ruta (puntosRuta) no son un array v√°lido de coordenadas [[lat,lng],...] o est√°n vac√≠os.'
          );
        }
      } catch (parseError) {
        console.error(
          `[Simulaci√≥n] Error al parsear/validar puntos de ruta ID ${routeId}:`,
          parseError,
          'Valor:',
          rutaEncontrada.puntosRuta
        );
        socket.emit('simulationError', {
          message: `Error en el formato de los puntos para la ruta ${routeId}.`,
        });
        return;
      }

      let puntoActualIndex = 0;
      const intervaloDeSimulacionMs = 2000;

      console.log(
        `[Simulaci√≥n] Iniciando para Ruta "${nombreDeLaRuta}" (ID ${routeId}), Veh√≠culo ID=${vehicleNumericId}, Asignaci√≥n ID=${asignacionIdSimulacion}, con ${puntosSimulacionArray.length} puntos.`
      );
      socket.emit('simulationStarted', {
        routeId,
        vehicleId: vehicleNumericId,
        asignacionId: asignacionIdSimulacion,
        routeName: nombreDeLaRuta,
      });

      socket.simulationIntervalId = setInterval(async () => {
        if (puntoActualIndex >= puntosSimulacionArray.length) {
          console.log(
            `[Simulaci√≥n] Fin para Ruta "${nombreDeLaRuta}", Veh√≠culo ID=${vehicleNumericId}, Asignaci√≥n ID=${asignacionIdSimulacion}`
          );
          if (socket.simulationIntervalId)
            clearInterval(socket.simulationIntervalId);
          delete socket.simulationIntervalId;

          const endData = {
            routeId,
            vehicleId: vehicleNumericId,
            asignacionId: asignacionIdSimulacion,
            routeName: nombreDeLaRuta,
          };
          if (asignacionIdSimulacion) {
            io.to(`asignacion_${asignacionIdSimulacion}`).emit(
              'simulationEnded',
              endData
            );
          } else {
            io.emit('simulationEnded', endData);
          }
          return;
        }

        const [latitudActual, longitudActual] =
          puntosSimulacionArray[puntoActualIndex];
        const datosActualizacionVehiculo = {
          idVehi: vehicleNumericId,
          latitud: latitudActual,
          longitud: longitudActual,
          asignacionId: asignacionIdSimulacion,
        };

        console.log(
          `[Simulaci√≥n] Ruta "${nombreDeLaRuta}" [${puntoActualIndex + 1}/${
            puntosSimulacionArray.length
          }]: Veh√≠culo ID=${vehicleNumericId} -> [Lat: ${latitudActual}, Lon: ${longitudActual}], Asignaci√≥n ID=${asignacionIdSimulacion}`
        );

        if (asignacionIdSimulacion) {
          io.to(`asignacion_${asignacionIdSimulacion}`).emit(
            'vehicleUpdated',
            datosActualizacionVehiculo
          );
        } else {
          io.emit('vehicleUpdated', datosActualizacionVehiculo);
        }
        puntoActualIndex++;
      }, intervaloDeSimulacionMs);
    } catch (error) {
      console.error(
        `[Simulaci√≥n] Error general procesando simulaci√≥n para ruta ID ${routeId}:`,
        error
      );
      socket.emit('simulationError', {
        message: `Error interno al procesar simulaci√≥n para ruta ${routeId}.`,
      });
      if (socket.simulationIntervalId) {
        clearInterval(socket.simulationIntervalId);
        delete socket.simulationIntervalId;
      }
    }
  });

  socket.on('stopSimulation', data => {
    const vehicleId = data?.vehicleId;
    console.log(
      `[Socket] Recibida petici√≥n 'stopSimulation' para veh√≠culo ${vehicleId} (o simulaci√≥n de este socket)`
    );
    if (socket.simulationIntervalId) {
      clearInterval(socket.simulationIntervalId);
      delete socket.simulationIntervalId;
      socket.emit('simulationStopped', {
        message: 'Simulaci√≥n detenida por el cliente.',
        vehicleId,
      });
      console.log(`[Simulaci√≥n] Detenida para socket ${socket.id}`);
    } else {
      socket.emit('simulationError', {
        message: 'No hay simulaci√≥n activa en este socket para detener.',
      });
    }
  });
});
const cron = require('node-cron');
const { verificarYGenerarOts } = require('./services/maintenanceScheduler');

// EXPLICACI√ìN: Se configura una tarea para que se ejecute todos los d√≠as a las 03:00 AM.
// Puedes cambiar el '0 3 * * *' para ajustar la frecuencia.
console.log('üïí Programando la tarea de verificaci√≥n de mantenimientos...');
cron.schedule('0 3 * * *', () => {
  console.log('‚è∞ Ejecutando tarea programada: Verificaci√≥n de Mantenimientos.');
  verificarYGenerarOts();
}, {
  scheduled: true,
  timezone: "America/Santiago" // Ajusta a tu zona horaria
});
const PORT = process.env.PORT || 8101;
server.listen(PORT, () => {
  console.log(
    `üöÄ Servidor Express con Socket.IO corriendo en http://localhost:${PORT}`
  );
});
